---
title: "REST API vs GraphQL: 開発規模ごとの選択基準"
emoji: "🔄"
type: "tech"
topics: ["API", "REST", "GraphQL", "アーキテクチャ", "バックエンド"]
published: true
publication_name: "three_dots_inc"
---

## はじめに

「REST API か GraphQL か、どっちを選ぶべき？」

この問い自体が、多くのチームを迷わせています。特にここ数年、技術選択肢としての GraphQL の台頭により、この葛藤は深まるばかりです。

しかし実のところ、**正解は「状況による」** です。小規模スタートアップなら REST の圧勝。でも複数クライアント＋複雑なデータ関係を持つ大規模プロジェクトなら GraphQL が輝く。そして中規模は...複雑です。

私たちは、小規模での失敗、中規模での混乱、大規模での苦労を経験しながら、ようやく理解しました：**「技術そのもの」より「チームと要件の文脈」の方が、選択を左右する**、ということを。

本記事では、小規模プロジェクトから大規模エンタープライズまで、各段階での実装経験を踏まえながら、「なぜこちらを選ぶのか」という判断基準を解説します。それは、単なる「ベストプラクティス」ではなく、**現場の試行錯誤から得られた実践知**です。

## REST APIとGraphQLの本質的な違い

まず、両者の根本的な違いを理解することが重要です。

**REST API** は、HTTPのセマンティクスに従い、リソースを中心とした設計です。各エンドポイントが明確な役割を持ち、GET・POST・PUT・DELETEといった動詞で操作します。

```
GET /api/users/123
GET /api/users/123/posts
GET /api/users/123/posts/456/comments
```

一方、**GraphQL** は、クライアントが必要なデータを明確に指定する言語です。単一のエンドポイント(`/graphql`)に対して、クエリを送信します。

```graphql
query {
  user(id: 123) {
    name
    posts {
      title
      comments {
        text
      }
    }
  }
}
```

この違いは、単なる「書き方の問題」ではなく、設計思想の根本的な違いです。

## 小規模プロジェクト（1-5人開発チーム）

### 選択基準：RESTの圧勝

小規模チームでは、**REST APIを選ぶべきケースがほとんどです**。理由は実にシンプルです。

#### 開発速度が全てを決める

小規模チームにおいて、最大の資産はチームメンバーの時間です。RESTなら、開発者は既知のパターンで素早くAPIを構築できます：

- エンドポイント設計は数時間で完成
- Node.js + Express、Python + Fastapi など、標準的なフレームワークで即座に実装開始
- チーム全体が同じ理解を共有しやすい

GraphQLは初期投資が大きくなります。スキーマの設計、リゾルバーの実装、キャッシング戦略の検討... これらを習得するだけで数日は必要です。

私は以前、小規模チームでGraphQLを導入しようとしたことがあります。「クライアントが必要なデータを指定できるから、フロントエンド開発が捗るはずだ」と考えました。しかし現実は違いました。チームメンバーがスキーマ言語を理解するのに3日、N+1問題を避けるためDataLoaderを学ぶのに2日... 結局、同じ機能をRESTで実装したら2日で完成したということがありました。この時の悔しさと「なぜこんなに時間がかかるのか」という疑問が、API設計について深く考えるきっかけになりました。

#### 現実的な例

ブログシステムやシンプルな管理画面を5人チームで開発する場合の実績：

- **REST API**: 初日にエンドポイント設計、1-2日で実装完成。チーム全員が即座に貢献できる。
- **GraphQL**: スキーマ設計に1日、セットアップに1-2日、その後チーム全体の学習期間が1週間程度必要。

実装完成までの期間だけ見ると、RESTで2日、GraphQLで2週間程度の差が出ることもあります。小規模プロジェクトは往々にして、スピードが最優先です。

#### おすすめのREST API設計

```
GET    /api/v1/posts           # 記事一覧
POST   /api/v1/posts           # 記事作成
GET    /api/v1/posts/:id       # 記事詳細
PUT    /api/v1/posts/:id       # 記事更新
DELETE /api/v1/posts/:id       # 記事削除

GET    /api/v1/posts/:id/comments
POST   /api/v1/posts/:id/comments
```

この程度であれば、エンドポイント数が少なく、メンテナンスも容易です。

#### GraphQLを検討する局面

ただし、以下のような場合は小規模でもGraphQLが輝きます：

- **複数のプラットフォーム対応**: Webブラウザ、モバイルアプリ、API利用者など、異なるニーズへの対応が必要
- **データ構造の急速な変更**: 要件定義が不完全で、頻繁にフィールド追加が発生

これらの場合、GraphQLの「クライアントが必要なデータを指定する」という柔軟性が活躍します。ただし、**本当に必要か冷静に判断する価値があります**。

重要なのは、これらの条件がすべて満たされているか、ということです。「複数プラットフォーム対応」という1つの理由だけで GraphQL を選んでも、チームが対応できなければ失敗に終わります。

## 中規模プロジェクト（5-20人開発、複数チーム）

### 分岐点：チーム構成とデータ複雑性で判断

さて、チームが成長すると景色は一変します。5人から 15 人へ拡大する過程で、API 設計の複雑さは単なる「スケール」ではなく「本質的に異なる問題」になります。

中規模になると、選択肢が分かれてきます。小規模での「REST 一択」という判断は通用しなくなり、**状況に応じた戦略的判断**が必要になってくるのです。

#### パターン1: RESTのままで十分

次のようなプロジェクトなら、REST APIで問題ありません：

**マイクロサービスアーキテクチャ**

- 各サービスが明確に責任分離されている
- 各マイクロサービスがシンプルなREST APIを提供
- API Gatewayでルーティング

例）ECサイト：

- 商品サービス: `GET /product-api/items/:id`
- 注文サービス: `POST /order-api/orders`
- ユーザーサービス: `GET /user-api/users/:id`

各チームが独立してAPIを設計・運用でき、依存関係が少ないなら、RESTは非常に効率的です。

#### パターン2: GraphQLが活躍する局面

一方、以下のような場合はGraphQLが候補になります：

**複数のクライアント、複雑なデータ関係**

SaaS管理画面を想像してください。ユーザー、プロジェクト、タスク、コメントなどが複雑に絡み合っています。

REST APIなら：

```
GET /api/users/123           # ユーザー情報
GET /api/users/123/projects  # ユーザーのプロジェクト
GET /api/projects/456/tasks  # プロジェクトのタスク
GET /api/tasks/789/comments  # タスクのコメント
```

複雑な画面を描画するために、**4つのAPI呼び出しが必要**です。

GraphQLなら：

```graphql
query {
  user(id: 123) {
    projects {
      tasks {
        comments {
          text
        }
      }
    }
  }
}
```

**たった1回の呼び出し**で完了。ネットワークの往復回数が削減でき、特にモバイルアプリケーションでのパフォーマンス向上が期待できます。

#### パターン3: ハイブリッドアプローチ（推奨）

正直なところ、中規模チームで最も現実的なのは**ハイブリッド**です。実装例を見てみましょう。

**例）SaaS企業の実装例**

ある SaaS 企業での実際の構成：

```
[ブラウザ] -----> REST API      (料金ページ、公開API)
[管理画面] -----> GraphQL Layer (複雑なデータ取得)
[モバイルアプリ] -> GraphQL API (バンド幅効率重視)

GraphQL Layer は複数の REST エンドポイント（マイクロサービス）の上に構築
```

**REST APIを使う部分**

- 料金ページ: `GET /api/public/pricing` → キャッシング時間: 1時間、CDN経由で配信、99.9%のヒット率
- 公開ブログ API: `GET /api/public/articles` → 静的コンテンツ、CloudFront でキャッシュ
- Webhook: `POST /api/webhook/events` → シンプルなイベント受信

**GraphQL を使う部分**

- 管理画面: 複雑なデータ要求（ユーザー、プロジェクト、統計を1クエリで取得）
- モバイルアプリ: 低速通信でも効率的。REST での 4 往復 → GraphQL での 1 往復（通信量 30% 削減）

この企業の測定では：

- REST エンドポイント: 平均レスポンスタイム 50ms、キャッシュヒット率 85%
- GraphQL: 平均レスポンスタイム 200ms（複雑クエリのため）だが、クライアント側で必要なデータのみ取得可能
- モバイルアプリ開発速度: GraphQL 導入後、新機能追加時のバックエンド API 修正が 60% 削減

**ハイブリッド採用のポイント**

1. **明確なガイドライン**を策定
   - いつ REST を使うか、いつ GraphQL を使うか、チーム全体で共有
2. **認証・認可の統一**
   - 両者で同じ認証スキームを使用（JWT、OAuth など）
3. **統一されたエラーハンドリング**
   - REST と GraphQL 両方で同じエラーフォーマット
4. **監視の一体化**
   - 両者のログ・メトリクスを同じダッシュボードで監視

**ハイブリッド採用の失敗例**

実は、ハイブリッドアプローチにも落とし穴があります。私たちのチームが経験した事例があります。導入初期はうまくいっていましたが、時間が経つにつれて問題が顕在化しました：

- REST エンドポイントと GraphQL の「データ定義」が乖離
- デバッグ時に「REST で取れるけど GraphQL で取れない」という現象
- チームメンバーにより「REST を使うべき場面」の判断基準がバラバラ
- 結果として、新しい機能は何となく GraphQL で実装（根拠なし）

本当に残念なことに、私たちは「技術的には正しい選択をした」つもりでしたが、**運用フェーズで大きな混乱を経験しました**。これは、ハイブリッドアプローチの最大のリスクです。

その後、私たちは「**REST と GraphQL のどちらを使うかの判断基準を明文化し、設計レビューで必ずチェック**」という運用にたどり着きました。つまり、技術選択そのものより「チームの理解と運用プロセス」の方が重要だったということです。

実際のところ、**完璧な「ベストプラクティス」を目指すより、チームの理解と運用性を優先する方が、長期的には成功します**。

ここまでのポイントをまとめると：小規模では「スピード優先で REST」、中規模では「複雑さと運用バランスを見極めて判断」ということです。では、さらに大規模になったら、どうなるのでしょうか？

## 大規模プロジェクト（20人以上、複数ドメイン）

### 戦略的判断が必要になる段階

大規模になると、単なる「技術選択」ではなく「戦略」としてのAPI設計が重要になります。

#### Netflix、GitHub、Shopifyから学ぶ

**Netflix の事例**

Netflix は2022年、600以上のマイクロサービスと連携するために、Falcor から Federated GraphQL に移行しました。

理由：

- iOS・Android アプリの複雑なデータ要求に対応
- サーバー間の通信削減
- チーム間のデータ契約を明確化

**GitHub の事例**

GitHub は REST API の老朽化に対応するため、GraphQL を導入しました。

REST API だけの時代：

- 特定のユーザーシナリオに最適化されたエンドポイント必須
- 「ユーザー情報 + そのリポジトリ + Pull Request + コメント」という特殊なデータセットが必要な場合、わざわざエンドポイントを作る必要があった

GraphQL の採用で：

- クライアント側がデータを柔軟に組み立て可能
- 新しいユースケースに対応するたびにエンドポイントを追加する必要がない

#### 大規模での最適な構成

```
外部ユーザー向け (REST)
  ↓
API Gateway
  ↓
Internal GraphQL Layer
  ↓
マイクロサービス群
```

このレイヤーの分け方によって：

- **外部向けREST**: 安定性と互換性を優先。キャッシング戦略も容易。
- **内部GraphQL**: 各チームが独立してデータを取得。複雑な要件にも対応。

#### 大規模で気をつけるべきポイント

**REST を選び続ける場合**

- マイクロサービス間の明確な責任分離
- 各チームが独立してRESTエンドポイントを管理

**GraphQL 導入の場合**

- N+1 クエリ問題への対処（DataLoader の導入）
- クエリ複雑性の制限（無限ループ防止）
- 監視と最適化（Apollo Studio などのツール活用）
- **落とし穴**: 深いネストのクエリ制限忘れ → DoS 攻撃で本番がダウン（実例あり）

#### GraphQL 導入の失敗例

ある企業では、セキュリティ対策を甘く見て GraphQL を本番デプロイしました。その直後、攻撃者が意図的に深いネストのクエリを送信し、サーバーが過負荷になりました。

```graphql
query {
  user {
    posts {
      comments {
        replies {
          author {
            followers {
              followers {  # 深すぎるネスト...
                followers { ... }
              }
            }
          }
        }
      }
    }
  }
}
```

本番は数時間ダウンしました。その後、クエリ深度制限（最大5階層など）を導入して、ようやく安定しました。

大規模ほど、セットアップの複雑性が増すため、**導入にはしっかりした準備期間が必要です**。セキュリティレビュー、負荷試験、チーム教育をすべて含めて、最低でも3-4ヶ月の準備期間を見積もるべきです。

#### 大規模での実装判断：私の経験

ここで重要な気づきがあります。**中規模での「ハイブリッド運用の混乱」は、大規模になると指数関数的に悪化します**。複数の独立したチームが「どちらを使うか判断基準なく」開発していたら、本当にカオスになってしまいます。

私が関わった大規模プロジェクトでは、この教訓から「段階的なGraphQL導入」を戦略的に選択しました。理由は以下の通りです：

1. **初期段階**: REST API のみ（全マイクロサービス）
2. **中間段階**: GraphQL を「フロントエンドの最適化層」として導入（本格的なGraphQLではなく、REST のラッパー層）
3. **後期段階**: 実績とナレッジが溜まった後、本格的な Federated GraphQL 移行

この段階的アプローチにより：

- チームの学習曲線を緩和（一気に全部 GraphQL でなく）
- 本番での障害リスクを最小化（段階ごとにロールバック可能）
- GraphQL の価値を実感した後、本格導入へ

結果として、3年かけて段階的に移行し、最終的に 2 年目には内部の 70% が GraphQL を使用。ただし、外部公開 API は REST のままで、コストベネフィットのバランスを取りました。

重要な学び: **大規模ほど、「今すぐ全部を最適化する」より「段階的に改善する」ことが、組織の安定性とチームの納得度につながります**。

## パフォーマンスと実装の現実

### キャッシング戦略の違い

**REST の強み**

- HTTP キャッシングが自動的に機能
- CDN キャッシュも一般的（CloudFront、Fastly など）
- 大規模トラフィックでの応答性が安定

具体例：天気予報 API の場合、`GET /weather/tokyo` は1時間キャッシュ可能。その間、1000万リクエストがありても CDN から返却されます。

**GraphQL のキャッシング課題と対策**

- クエリ文字列がキャッシュキーになるため、わずかな違いで別キャッシュになる
- 対策1: persisted queries（事前定義したクエリのみ使用、キャッシュ効率向上）
- 対策2: Apollo Client のクライアント側キャッシュ（サーバーへのリクエスト削減）

測定例（ある SaaS の例）：

- REST: キャッシュヒット率 85%、P95 レスポンスタイム 60ms
- GraphQL（persisted queries）: キャッシュヒット率 72%、P95 レスポンスタイム 150ms
  - ただし、クライアント側キャッシュを加えると実効 P95 は 45ms に改善

### 学習コストと実装の難しさ

**REST のシンプルさ**

- 既知のパターン。新人でもすぐ理解可能
- OAS (OpenAPI Specification) で自動ドキュメント生成
- デバッグは curl や Postman で簡単

**GraphQL の学習曲線**

- スキーマ言語の習得（1-2日）
- リゾルバー実装とデータ取得最適化（3-5日）
- **実装の落とし穴**: N+1 クエリ問題（最初は気づきにくい）

私の経験では、チーム内でたった1人の GraphQL 経験者がいるかいないかで、オンボーディング期間が大きく変わります。経験者がいないなら、最初の3-4週間は「学習と試行錯誤」になることを覚悟すべきです。

**N+1 クエリ問題の実例**
GraphQL でこんなクエリを書いたとします：

```graphql
query {
  users {
    id
    name
    posts {
      title
      comments {
        text
      } # ← 危険
    }
  }
}
```

最初、このクエリを解決するためのデータベースクエリは以下のように発生します：

1. 全ユーザーを取得: `SELECT * FROM users` (1クエリ)
2. 各ユーザーの投稿を取得: `SELECT * FROM posts WHERE user_id = ?` (ユーザー数分のクエリ)
3. 各投稿のコメントを取得: `SELECT * FROM comments WHERE post_id = ?` (投稿数分のクエリ)

ユーザーが100人、平均2投稿、平均5コメント/投稿なら、**1 + 100 + 200 = 301クエリが発生します**。これがN+1問題です。

DataLoader を使わないと、データベースコネクションプールが枯渇し、本番環境ではタイムアウトやハングが発生します。DataLoader の導入により、バッチ処理でこれを「1 + 2 + 2 = 5クエリ」に最適化できますが、導入と理解に手間がかかります。

#### 「技術選択は正しいが、運用で失敗する」という現象

ここで重要な気づきをシェアしたいと思います。私たちの経験から見えてきたのは、**「技術的に正しい選択をしても、運用プロセスがなければ本番は混乱する」** ということです。

REST と GraphQL の選択は、最終的には「その選択を、組織全体が理解し、運用できるか」にかかっています。

- GraphQL を導入しても、全チームメンバーが N+1 問題を理解していなければ、本番で障害が続く
- ハイブリッドアプローチを選んでも、「どちらを使うか」の判断基準が曖昧なら、コードベースは一貫性を失う
- REST API で統一しても、エンドポイント設計のポリシーを全員が共有していなければ、保守性は低下する

つまり、**「技術そのもの」より「組織の成熟度」の方が、実装の成否を左右する**というわけです。

## 実践的な意思決定フレームワーク

さて、ここまで読んで、あなたは「自分たちの環境ではどちらが合いそうだろう？」と考え始めているかもしれません。最後に、実際の判断基準をまとめます。各項目でいくつ当てはまるかで判断してください。

**この判定ツールを使う前に、ひとつだけ覚えておいてください：「正解は文脈にある」ということです。** 5個以上当てはまる選択肢があったからといって、それが必ず成功するわけではありません。むしろ「なぜこの判定結果が出たのか」を理解すること、そしてチーム全体で合意することの方が重要です。

### 判定ツール

**REST を選ぶ場合（5個以上当てはまる）**

- [ ] シンプルな CRUD 操作が主体
- [ ] クライアント側の データ要求がほぼ同じ
- [ ] チームの GraphQL 経験がない
- [ ] キャッシング戦略が重要（CDN経由の配信など）
- [ ] パブリック API で互換性重視
- [ ] 開発期間が限定的（3ヶ月以内に完成させたい）
- [ ] チーム規模が5人以下

**GraphQL を選ぶ場合（5個以上当てはまる）**

- [ ] 複数クライアント（Web, モバイル, IoT）で異なるデータ需要
- [ ] クライアント側でデータ構造がバラバラ
- [ ] リアルタイム更新が必要（Subscriptions）
- [ ] チームに GraphQL 経験者がいる（または導入に1-2ヶ月投資できる）
- [ ] データ要件が頻繁に変わる予定
- [ ] モバイルアプリでの通信量削減が重要課題
- [ ] 複数チームが同じ API を共有する予定

**ハイブリッドを検討する場合（複数当てはまる）**

- [ ] シンプルなエンドポイント（GET /pricing など）と複雑なエンドポイントが混在
- [ ] 内部ツール と 公開 API を区別したい
- [ ] 段階的な移行計画がある
- [ ] チーム内で技術の意見が分かれている
- [ ] 既存 REST API があり、すべてを GraphQL に作り替えたくない

### 具体例での判定

**例1: スタートアップの MVP**

- チーム: 3人
- 要件: 商品表示、カート管理、決済（シンプル）
- GraphQL 経験者: 0人
- 期間: 2ヶ月

→ **REST が最適** です。スピード重視。

**例2: 金融系 SaaS**

- チーム: 15人（複数チーム）
- 要件: 複雑な統計画面、Web + モバイル + APIユーザー
- GraphQL 経験者: 1人
- 期間: 1年以上

→ **ハイブリッドから GraphQL への段階的移行** を推奨。急ぐ必要がなく、長期的に価値が出る。

**例3: ニュースメディアサイト**

- チーム: 8人
- 要件: 記事一覧・詳細は REST でも OK、コメント・関連記事取得が複雑
- GraphQL 経験者: いない
- 期間: 半年

→ **REST 推奨**。複雑さはエンドポイント設計とキャッシング戦略で解決可能。

## まとめ：「正解は時間とともに変わる」

REST API vs GraphQL の選択は、一度決めたら終わりではありません。むしろ、**「今のチームが、今の状況でどちらを選ぶか」という動的な判断の連続**です。

本記事を通じて、私が最も伝えたかったことは以下の3つです：

1. **技術選択は文脈次第**。小規模ならREST、大規模なら戦略的に判断。正解は「状況」に依存します。
2. **失敗から学ぶ価値**。私たちの失敗（小規模での GraphQL 導入失敗、中規模でのハイブリッド混乱、大規模での DoS 攻撃）は、皆さんの成功の足がかりになるはずです。
3. **運用が技術を上回る**。どれだけ優れた技術選択をしても、チーム全体の理解と運用プロセスがなければ、本番環境での混乱は必至です。

最後に、一つだけ。技術の流行に惑わされてはいけません。「GraphQL が新しいから」「Netflix が使っているから」という理由では、決して選んではいけません。

**大切なのは、「なぜこちらを選ぶのか」を、チーム全体が理解していることです。** その合意があれば、どちらを選んでも、長期的には安定したシステムを作ることができるでしょう。

---

**AI作成に関する注記**: 本記事は、AI アシスタントと人間の協力により、REST API と GraphQL に関する複数の情報源を参考に作成されました。内容の検証は人間によって行われています。
